# Lesson Plan Creation Flow

**Date:** 2025-12-30  
**Status:** ✅ **DOCUMENTED** - Complete flow from API request to DomainPlan generation

## Executive Summary

The lesson plan (DomainPlan) is created automatically during lesson compilation. It's generated by the LLM using the `gen_domain_plan()` function, which takes a CanDo descriptor and generates a structured plan that guides all subsequent lesson content generation.

## Who Creates the Lesson Plan?

### 1. API Endpoint ✅

**File**: `app/api/v1/endpoints/cando.py`

**Endpoints**:
- `POST /api/v1/cando/{can_do_id}/compile` - `compile_lesson_v2()`
- `POST /api/v1/cando/{can_do_id}/compile/stream` - `compile_lesson_v2_stream()`

**Who calls it**:
- Frontend application (user initiates lesson compilation)
- Lesson session service (when starting a lesson)
- Any service that needs to compile a lesson

**Parameters**:
- `can_do_id`: CanDo descriptor ID (e.g., "JFまるごと:1")
- `user_id` (optional): User ID for personalization
- `metalanguage` (optional): Target language code (default: "en")

### 2. Compilation Service ✅

**File**: `app/services/cando_v2_compile_service.py`

**Function**: `compile_lessonroot()`

**What it does**:
1. Fetches CanDo metadata from Neo4j
2. Fetches pre-lesson kit from learning path (if user_id provided)
3. Builds user profile context (if user_id provided)
4. **Generates DomainPlan** (lesson plan)
5. Generates Content stage cards
6. Generates Comprehension, Production, Interaction stages (in background)
7. Assembles final lesson

### 3. DomainPlan Generator ✅

**File**: `scripts/cando_creation/generators/cards.py`

**Function**: `gen_domain_plan()`

**What it does**:
- Calls LLM with planner prompt
- Validates response against DomainPlan Pydantic model
- Returns structured DomainPlan object

## How is the Lesson Plan Created?

### Step-by-Step Flow

```
1. User/Service calls API endpoint
   POST /api/v1/cando/{can_do_id}/compile?user_id={user_id}
   ↓
2. API endpoint (cando.py)
   - Extracts can_do_id, user_id, metalanguage
   - Calls compile_lessonroot()
   ↓
3. Compilation Service (cando_v2_compile_service.py)
   - compile_lessonroot() function
   ↓
4. Fetch CanDo Metadata
   - Queries Neo4j for CanDo descriptor
   - Extracts: uid, level, topics, description, etc.
   ↓
5. Fetch Pre-lesson Kit (if user_id provided)
   - _fetch_prelesson_kit_from_path()
   - Searches learning_paths table
   - Extracts kit from path_data.steps[].prelesson_kit
   ↓
6. Build User Profile Context (if user_id provided)
   - _build_user_profile_context()
   - Queries user_profiles and users tables
   - Formats profile data into context string
   ↓
7. Generate DomainPlan (Lesson Plan) ⭐
   - pipeline.gen_domain_plan()
   - Calls gen_domain_plan() in cards.py
   ↓
8. DomainPlan Generator (cards.py)
   - build_planner_prompt() - Creates LLM prompt
   - validate_or_repair() - Calls LLM and validates response
   - Returns DomainPlan object
   ↓
9. DomainPlan Structure
   - communicative_function_en/ja
   - scenarios (1-2 contexts with roles)
   - lex_buckets (3-5 vocabulary buckets)
   - grammar_functions (2-5 grammar patterns)
   - evaluation (success_criteria, discourse_markers)
   - cultural_themes_en/ja
   ↓
10. DomainPlan used for Content Stage Generation
    - All content cards use plan as input
    - Objective, Words, Grammar, Dialogue, Reading, Culture
```

### DomainPlan Generation Details

#### Input to LLM

**Prompt Builder**: `scripts/cando_creation/prompts/planner.py` - `build_planner_prompt()`

**Inputs**:
1. **CanDo Descriptor**:
   - `uid`: CanDo ID (e.g., "JFまるごと:1")
   - `level`: Proficiency level (e.g., "A1")
   - `primaryTopic_ja/en`: Topic in Japanese and English
   - `skillDomain_ja`: Skill domain
   - `type_ja`: Type of CanDo
   - `description.en/ja`: Description
   - `source`: Source (e.g., "JFまるごと")

2. **Pre-lesson Kit Context** (optional):
   - `kit_context`: Formatted string with necessary words, grammar, phrases
   - `kit_requirements`: Requirements from learning path

3. **User Profile Context** (optional):
   - `profile_context`: Formatted string with:
     - Learning goals
     - Previous knowledge
     - Usage context (register preferences, scenario details)
     - Learning preferences (grammar focus, exercise types)
     - Path-level structures (vocabulary/grammar/expression goals)
     - Cultural interests

#### LLM Processing

**System Prompt**: `STRICT_SYSTEM` (from `prompts/constants.py`)
- Instructs LLM to return only valid JSON
- No explanations, no markdown, strict JSON only

**User Prompt**: Structured prompt that:
1. Describes the task: "Derive a DomainPlan solely from the CanDoDescriptor"
2. Lists required components:
   - `communicative_function_*`: Restate CanDo as function
   - `scenarios`: 1-2 plausible contexts with roles
   - `lex_buckets`: 3-5 vocabulary buckets (6-14 items each)
   - `grammar_functions`: 2-5 grammar patterns
   - `evaluation`: Success criteria and discourse markers
   - `cultural_themes_*`: 2-5 cultural/pragmatic themes
3. Includes constraints:
   - Level-appropriate content
   - No hardcoded domain content
   - Natural Japanese
4. Includes personalization instructions (if profile_context provided):
   - Use register preferences for scenarios
   - Use cultural interests for themes
   - Use scenario details for specific contexts
   - Use grammar focus areas for grammar selection
   - Align with learning goals and usage context

#### Output Validation

**Model**: `scripts/cando_creation/models/plan.py` - `DomainPlan`

**Validation**:
- Pydantic model validates structure
- `validate_or_repair()` handles validation errors
- If validation fails, LLM is asked to repair (max 2 attempts)
- Returns validated DomainPlan object

### DomainPlan Structure

**File**: `scripts/cando_creation/models/plan.py`

```python
class DomainPlan(BaseModel):
    """Lesson plan derived from CanDo descriptor."""
    
    # Communicative function
    communicative_function_en: str
    communicative_function_ja: str
    
    # Scenarios (1-2 contexts)
    scenarios: List[PlanScenario]  # Each with roles, register, context
    
    # Vocabulary buckets (3-5 buckets)
    lex_buckets: List[PlanLexBucket]  # Each with 6-14 items
    
    # Grammar functions (2-5 patterns)
    grammar_functions: List[PlanGrammarFunction]  # Each with id, pattern, slots
    
    # Evaluation criteria
    evaluation: PlanEvaluation  # success_criteria, discourse_markers
    
    # Cultural themes
    cultural_themes_en: List[str]
    cultural_themes_ja: List[str]
    
    # Metadata
    level: str  # e.g., "A1"
```

## When is the Lesson Plan Created?

### Timing

1. **During Lesson Compilation**:
   - Plan is generated **first** (before any content cards)
   - Content stage generation depends on plan
   - Plan is used as input for all subsequent stages

2. **Synchronous Generation**:
   - Plan generation is **blocking** (not async)
   - Must complete before content generation starts
   - Typically takes 5-15 seconds (LLM call)

3. **Caching**:
   - Plan is **not cached** separately
   - Plan is part of the compiled lesson
   - If lesson is regenerated, plan is regenerated

## Where is the Lesson Plan Stored?

### Storage Location

**Not stored separately** - Plan is embedded in the compiled lesson:

1. **In-Memory**:
   - DomainPlan object exists during compilation
   - Passed to all stage generators

2. **In Compiled Lesson**:
   - Lesson JSON includes plan data
   - Stored in lesson storage (Neo4j or file system)
   - Retrieved when lesson is loaded

3. **Not in Database**:
   - No separate `lesson_plans` table
   - Plan is part of lesson metadata
   - Regenerated each time lesson is compiled

## Key Functions and Files

### Core Functions

1. **`compile_lessonroot()`** (`cando_v2_compile_service.py`)
   - Main orchestration function
   - Calls `gen_domain_plan()`

2. **`gen_domain_plan()`** (`scripts/cando_creation/generators/cards.py`)
   - Generates DomainPlan from CanDo
   - Calls `build_planner_prompt()` and `validate_or_repair()`

3. **`build_planner_prompt()`** (`scripts/cando_creation/prompts/planner.py`)
   - Creates LLM prompt for plan generation
   - Includes CanDo, kit context, profile context

4. **`validate_or_repair()`** (`scripts/cando_creation/generators/utils.py`)
   - Calls LLM and validates response
   - Handles repair attempts if validation fails

### Key Files

- **API**: `app/api/v1/endpoints/cando.py`
- **Service**: `app/services/cando_v2_compile_service.py`
- **Generator**: `scripts/cando_creation/generators/cards.py`
- **Prompt**: `scripts/cando_creation/prompts/planner.py`
- **Model**: `scripts/cando_creation/models/plan.py`

## Personalization

### How Profile Affects Plan Generation

When `user_id` is provided and profile exists:

1. **Profile Context is Built**:
   - `_build_user_profile_context()` formats profile data
   - Includes all profile fields (goals, preferences, path-level structures)

2. **Profile Context is Passed to Planner**:
   - `build_planner_prompt()` receives `profile_context` parameter
   - Profile context is included in LLM prompt

3. **LLM Uses Profile for Personalization**:
   - **Scenarios**: Uses `register_preferences` and `scenario_details`
   - **Vocabulary**: Uses `vocabulary_domain_goals`
   - **Grammar**: Uses `grammar_progression_goals` and `grammar_focus_areas`
   - **Cultural Themes**: Uses `cultural_interests`
   - **Difficulty**: Matches `current_level`

4. **Result**:
   - Plan is personalized to user's goals, preferences, and level
   - All subsequent content generation uses personalized plan

## Example Flow

```python
# 1. API Request
POST /api/v1/cando/JFまるごと:1/compile?user_id=123e4567-e89b-12d3-a456-426614174000

# 2. Compilation Service
plan = await pipeline.gen_domain_plan(
    llm_call_main,
    cando_input,  # From Neo4j
    metalanguage="en",
    kit_context=kit_context,  # From learning path
    kit_requirements=kit_requirements,
    profile_context=profile_context  # From user profile
)

# 3. DomainPlan Generated
DomainPlan(
    communicative_function_en="Order food at a restaurant",
    communicative_function_ja="レストランで食べ物を注文する",
    scenarios=[...],  # Personalized scenarios
    lex_buckets=[...],  # Vocabulary aligned with user goals
    grammar_functions=[...],  # Grammar aligned with user focus
    evaluation=...,
    cultural_themes_en=[...],  # Themes aligned with interests
    cultural_themes_ja=[...]
)

# 4. Plan Used for Content Generation
content_cards = await pipeline.gen_content_stage(
    ...,
    plan=plan,  # Plan guides all content generation
    ...
)
```

## Summary

**Who**: 
- API endpoint receives request
- Compilation service orchestrates
- DomainPlan generator creates plan
- LLM generates plan content

**How**:
- LLM-based generation from CanDo descriptor
- Prompt includes CanDo metadata, pre-lesson kit, user profile
- Validated against DomainPlan Pydantic model
- Plan guides all subsequent lesson content generation

**When**:
- During lesson compilation (first step)
- Synchronous (blocks until complete)
- Regenerated each time lesson is compiled

**Where**:
- Not stored separately
- Embedded in compiled lesson
- In-memory during compilation

**Personalization**:
- Profile context included in planner prompt
- LLM uses profile to personalize scenarios, vocabulary, grammar, themes
- Plan reflects user's goals, preferences, and level

